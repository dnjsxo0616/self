# 문제

- 구름이는 다가오는 크리스마스에 커플이 아닌 지인들을 서로 소개해 주기로 한다. 구름이는 최대한 많은 커플들이 생기기 바라는 마음으로 아래의 기준으로 지인들에게 점수를 부여한다.

  - 구름이의 지인의 수는 항상 짝수이다.
  - 모든 점수는 0점을 제외한 정수이다.
  - 지인들 중 같은 점수를 가지고 있는 경우는 없다.
  - 만약에 n점을 가진사람이 있다면 -n점을 가진 사람이 항상 존재한다.

- 구름이는 지인들 중 점수를 합한 값이 0이 되는 두 명을 짝지어서 소개팅을 진행하기로 한다. 구름이는 위와 같은 규칙으로 지인의 점수를 부여하다가 실수로, 네 번째 규칙을 지키지 못했다. 그래서 두 사람이 소개팅을 받지 못하게 되었다. 이때 소개팅을 받지 못한 두 사람의 점수를 합한 값을 출력하시오.

# 입력

- 첫째 줄에 구름이의 지인의 수 `N`이 주어진다.
- 둘째 줄에 구름이가 지인들에게 부여한 점수 $S_1$, ....., $S_N$이 공백을 두고 주어진다.
  - 2 $\le$ N $\le$ 100,000; N은 짝수이다.
  - -200,000 $\le$ $S_i$ $\le$ 200,000; $S_i$ $\ne$ 0
  - 입력에서 주어지는 모든 수는 정수이다.

# 출력

- 구름이의 실수로 소개팅을 받지 못한 두 사람의 점수를 합한 값을 출력한다.

## 예시 1

### 입력

- 8
- 1 2 3 4 -1 -2 -3 -5

### 출력

- -1

# 문제 분석

- 문제에서 요구하는 것은 결국 `누가 소개팅을 진행하지 않았는가?`를 구하는 것이다.
- 문제의 조건에 따라, `n`점을 가진 사람이 소개팅을 진행하려면 그 사람과 합해서 점수가 0점이 되는 사람이 존재해야한다.
- 우리는 이러한 사람의 점수가 `-n`점임을 간단한 수학적 사고로 쉽게 파악할 수 있다. 따라서 어떤 사람이 소개팅을 진행하기 위해서는 그 사람과 점수의 절댓값이 같고 부호가 반대인 점수를 가진 사람이 존재해야 한다는 사실을 알 수 있다.

- 그러면 이제 문제는 `어떻게 절댓값이 같으면서 부호가 다른 점수 쌍을 찾을 수 있을 것인가?`로 바뀌게 된다.
- 하나의 테스트 케이스에서 나올 수 있는 점수 쌍의 개수는 `O(N)`개이므로, 제한 시간 안에 문제를 해결하기 위해서는 한 쌍을 찾는 시간이 `O(N)`보다는 빠르게 이루어져야 할 것이다.

# Hash 기반 자료구조 이용

- Hash Table은 Hash Function을 이용해 Key 값들을 정수로 변환한 뒤, 변환된 각 정수에 고유한 메모리 주소를 할당해서 `O(1)`의 시간 복잡도에 저장된 값들에 접근할 수 있게끔 하는 자료구조이다.
- python은 `dict`이란 자료구조가 Hash Table의 역할을 수행하고 있다.
- Hash Table을 이용한다면, 현재 내 점수와 같으면서 부호가 반대인 수가 존재하는 지를 점수당 `O(1)`시간에 빠르게 판별할 수 있다.
- 구현은 아래 코드를 참고하자.

```python
N = int(input())
S = list(map(int, input().split()))

occur = dict()
for i in range(N):
  # 현재 점수가 존재하는 지를 occur에 기록해둔다.
  occur[S[i]] = 1
  # dict{1:1, 2:1, 3:1, 4:1, -1:1, -2:1, -3:1, -5:1

ans = 0
for i in range(N):
  # 각 점수마다 부호가 반대인 점수 값이 occur에 존재하는 지를 확인한다.
  # key 값이 존재하는 경우에는 소개팅을 진행할 수 있다는 뜻이니, 넘어간다.
  if -S[i] not in occur:
    ans += S[i]

print(ans)
```

# 절댓값의 개수를 이용

- 문제에서 서로 중복되는 점수가 존재하지 않는다고 했기 때문에, 점수가 `n`점인 어떤 사람이 소개팅을 진행할 수 있다면 항상 `abs(n)`을 절댓값으로 가지는 점수는 항상 배열에서 2개가 존재한다.
- 반대로 소개팅을 진행하지 못한다면 그 사람이 가진 점수의 절댓값은 배열에서 하나가 존재한다.
- 따라서 점수의 절댓값들이 몇 번 등장하는 지를 세워 놓은 뒤, 점수의 절댓값이 한 번만 등장하는 경우에 다시 배열을 순회하면서 그 절댓값에 해당하는 사람의 점수를 답에 더해주는 식으로 문제를 해결할 수 있다.

```python
N = int(input())
S = list(map(int, input().split()))

occur = [0 for _ in range(200001)]
for i in range(N):
  # abs 함수는 인자로 들어온 수의 절댓값을 반환하는 함수이다.
  occur[abs(S[i])] += 1

ans = 0
for i in range(1, 200001):
  if occur[i] != 1:
    continue
  for j in range(N):
    if abs(S[j]) == i:
      ans += S[j]

print(ans)
```

# 아이디어

- 위의 풀이도 구현이 크게 어렵진 않지만, 조금 다른 방식으로 문제 접근을 하면 훨씬 간단하게도 문제를 해결할 수 있다.
- 소개팅을 진행하지 않은 두 사람의 점수의 합은 전체 점수의 합에서 소개팅을 진행한 사람들의 점수의 합을 뺀 값과 값다.
- 그런데 `소개팅을 진행한 사람들의 점수의 합은 항상 0이 된다`는 사실 때문에, 문제에서 구하고자 하는 답은 `항상 전체 점수의 합과 같다.`
- 이러한 사실을 파악했다면, 아래 코드와 같이 훨씬 간단한 구현으로 문제를 해결할 수 있다.

```python
import sys
input = sys.stdin.readline

N = int(input())
nums = list(map(int, input().split()))
print(sum(nums))
```
