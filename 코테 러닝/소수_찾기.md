# 문제 분석
- 어떤 수가 소수인지 판별하기
- 소수 번째에 위치한 값들 합치기

# 소수 판정하기
- 1과 자기자신만 나누어 떨어지는 수를 `소수`라고 한다. 
- 어떤 수가 소수인지 판정하는 문제는 프로그래밍을 처음 배울 때 예제로 자주 등장하는 문제이다.

```python
# 어떤 수 N이 소수인지 판정해보자
# 1과 N사이에 있는 수들 중, N의 약수인게 있으면 소수가 아니다
is_prime = 1
for i in range(2, N):
  if N % i == 0:
    is_prime = 0
```

- 위 코드처럼 소수의 개념을 그대로 옮기기만 해도 어떤 수가 소수인지는 판별할 수 있다. 그런데 이렇게 해도 괜찮은 걸까? 한 번 시간복잡도를 계산해보자!
- 문제에서 주어지는 수열의 길이는 N이기 때문에, 소수 판별도 N번 해야 한다. 그런데 매 판별마다 반복문을 N번 돌고 있으니, `시간복잡도는 O(N^2)`이 된다.
- N이 10만이니 시간 제한을 맞추기는 쉽지 않아 보인다. 아무래도 조금 더 효율적으로 소수 판별을 해야한다.
- 한 번 소수 판별을 할 때 매번 N-1까지 반복문을 돌아야 할까? 곱셈의 성질을 잘 생각해보면 그렇지 않다는 것을 알 수 있다.
- 어떤 수 x가 y로 나누어 떨어진다는 말은 x/y로 나누어 떨어진다는 말이기도 하다.
- 이런 대칭적인 성질로 인해, 실질적으로 루트N 까지만 반복문을 돌아도 N의 모든 약수를 구할 수 있음을 알 수 있다.
- 이제 시간복잡도는 O(N^3/2)로 줄어들었고, 문제를 해결하기에 충분한 시간이 되었다.

# 에라토스테네스의 체
- 하나의 수가 소수인지 판별할 때는 위 방법도 충분히 효율적입니다. 그러나 이 문제처럼 소수를 `여러 번 판별`해야 할 때는 `에라토스테네스의 체`를 사용하는 것이 더 효율적이다.
- 보통 10^12 정도로 큰 수의 소수 판별을 할 때는 위의 방식을 사용하고, 10^6 정도 이하의 `모든 소수`를 구하고 싶을 때는 에라토스테네스의 체를 이용하는 방식을 사용한다.
- 어떻게 구현하고, 어떻게 사용해야 하는 지 조금 더 알아보자!
- 기본 아이디어는 `어떤 수의 약수를 세는 것 보다는 배수를 세는 것이 훨씬 쉽다는 것`에서 출발한다.
- 그래서 어떤 수가 소수인지를 판정하는 것이 아니라, `어떤 수가 소수가 아닌지`를 판정하는 방식으로 동작합니다. 아이디어는 그렇고, 구현은 2부터 순서대로 보면서 그 수가 소수인 경우에만 배수들을 모두 소수가 아니라고 판정합니다. 동작 과정을 그림으로 살펴보자

![소수 동작1](./image/%EC%86%8C%EC%88%98%EB%8F%99%EC%9E%911.png)

- 1은 소수가 아니므로 예외적으로 건너뛴다. 그리고 2는 소수이므로, 2의 배수에 해당하는 4, 6, ....60을 소수 후보에서 지워준다.

![소수 동작2](./image/%EC%86%8C%EC%88%98%EB%8F%99%EC%9E%912.png)

- 그 다음 3도 소수이므로, 3의 배수에 해당하는 값들을 역시 후보에서 지워준다.

![소수 동작3](./image/%EC%86%8C%EC%88%98%EB%8F%99%EC%9E%913.png)

- 그 다음값인 4는 소수가 아니라고 판정되었으므로 건너뛰고 5는 소수이므로 배수에 해당하는 값들을 다 지워준다.

![소수 동작4](./image/%EC%86%8C%EC%88%98%EB%8F%99%EC%9E%914.png)

- 위 과정을 N 이하의 모든 수들에 대해 반복한다. 그러면 최종적으로 걸러진 소수들은 아래 그림과 같이 나온다.

![소수 동작5](./image/%EC%86%8C%EC%88%98%EB%8F%99%EC%9E%915.png)

- 이렇게 소수들을 체를 이용해서 구해보았다. 이 방식으로 구현한 에라토스테네스의 체는 O(NloglogN)에 동작함이 잘 알려져 있다.
- 앞선 소수 판정 방식의 시간복잡도와 비교해보면 상당히 빠르다는 것을 알 수 있다!
- 코드로는 아래와 같이 구현할 수 있다.

```python
def Sieve(N):
  # 초기에는 모두 소수일 수 있다고 가정한다.
  is_prime = [1 for _ in range(N + 1)]
  prime = []
  for i in range(2, N+1):
    # 소수가 아니라고 판정된 수는 건너뛴다
    if not is_prime[i]:
      continue
    
    prime.append(i)
    # 소수의 배수들을 쳐내는 과정
    for j in range(2 * i, N + 1, i):
      is_prime[j] = 0
  return prime
```

- 여기까지 했으면 이후의 과정은 간단하다. 배열에서 소수 위치에 해당하는 값들을 단순히 답에 더해주기만 하면 끝이다.
- 시간 복잡도는 O(NloglogN)이다.

# Code.

```python
import sys
input = sys.stdin.readline

def Sieve(N):
  is_prime = [1 for _ in range(N + 1)]
  prime = []
  for i in range(2, N + 1):
    if not is_prime[i]:
      continue
    prime.append(i)
    for j in range(2 * i, N + 1, i):
      is_prime[j] = 0
  return prime

N = int(input())
A = [0] + list(map(int, input().split()))
ans = 0

primes = Sieve(N)
for prime in primes:
  # 해당 위치하는 값을 더하기
  ans += A[prime]

print(ans)
```